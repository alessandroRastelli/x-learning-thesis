\newpage
\section{WebRTC: Overview}
\label{sec:WebRTC: Overview}


http://www.toptal.com/webrtc/taming-webrtc-with-peerjs

http://www.html5rocks.com/en/tutorials/webrtc/basics/


%%%%
X-Learning in addition to video streaming are given the opportunity to the teacher to schedule webinars.
The webinar is a live event, allowing more people to connect live to participate in an interactive lesson, a training course, a workshop or conference. Just like in real classroom we find ourselves at the scheduled time and everyone has the opportunity to attend and speak at the event to ask questions and share ideas.
To achieve this feature has been adopted WebRTC useful in all contexts of video conference.
%%%%

WebRTC born with the intention to offer Web Developers One Tool to manage the interchange of data stream between two devices direct connection ( peer-to -Peer ).
WebRTC (Web Real-Time Communication) is an API definition drafted by the World Wide Web Consortium (W3C) that supports browser-to-browser applications for voice calling, video chat, and P2P file sharing without the need of either internal or external plugins.[ How WebRTC Is Revolutionizing Telephony. Blogs.trilogy-lte.com (2014-02-21). Retrieved on 2014-04-11.]

Since it was first introduced by Google in May 2011, WebRTC has been used in many modern web applications. Being a core feature of many modern web browsers, web applications can seamlessly take advantage of this technology to deliver improved user experience in many ways. Video streaming or conferencing applications that don’t require bloated browser plugins, and can take advantage of peer-to-peer (P2P) networks (while not transmitting every bit of data through some server) is only a part of all the amazing things that can be achieved with WebRTC[http://www.toptal.com/webrtc/taming-webrtc-with-peerjs]
WebRTC is used in various apps like WhatsApp, Facebook Messenger, appear.in and platforms such as TokBox[http://www.html5rocks.com/en/tutorials/webrtc/basics/]

\subsection{Webinar implementation}
\label{sec:Webinar implementation}

For the creation of server side webinar it was used PeerJs that allows the establishment and management of video conferences in a more simple and
cleaner than WebRTC. client side instead was create two distinct a web component for the teacher and one for the student wishing to
connect to the webinar.

\subsubsection{Webinar: server side}
To work around the implementation differences of WebRTC, in X-Learning i use an JavaScript library: PeerJS.
PeerJS takes the implementation of WebRTC in your browser and wraps a simple, consistent, and elegant API around it. It plugs various holes in WebRTC implementation of earlier browsers. 
With PeerJS, identifying peers is even simpler. Every peer is identified using nothing but an ID. A string that the peer can choose itself, or have a server generate one. Although WebRTC promises peer-to-peer communication, you still need a server anyway to act as a connection broker and handle signaling. PeerJS provides an open source implementation of this connection broker server PeerJS Server (written in Node.js), in case you do not want to use their cloud-hosted version (which is free right now, and comes with some limitations).
In my project i Hosting my own PeerJS Server. The official repository on GitHub even has a one-click button to deploy an instance of PeerJS Server to Heroku.
In my case, i just want to create an instance of ExpressPeerServer in my Node.js application, and serve it at “/peerjs”

\begin{lstlisting}[language=javascript]
// peerjs server
  var options = {
      debug: true
  }
  app.use('/peerjs', ExpressPeerServer(server, options));

  server.listen(9000);
\end{lstlisting}


With PeerJS Server up and running, I move on to the client side. As discussed earlier, PeerJS identifies peers with unique IDs. These IDs can be generated by PeerServer for every peer automatically, or we can pick one for every peer while instantiating Peer objects.

\begin{lstlisting}[language=javascript]
var peer = new Peer(id, options)
\end{lstlisting}

Here, id can be omitted altogether if we want the server to generate one for us. In my case, that is what i will want to do.PeerServer will ensure that the IDs it gives out are unique.The second argument, options, is usually an object containing key (the API key, if you are using cloud-hosted PeerServer, or host, port, path, etc in case you are hosting the PeerServer yourself).

\begin{lstlisting}[language=javascript]
var peer = this.peer = new Peer( { host: 'localhost', port: 9000, path: '/peerjs'});
\end{lstlisting}

In order to establish a connection between two PeerJS peers, one of the peers must know the ID of the other peer.

With the destination peer ID known, a simple call to peer.connect(destId) is all that we will need

\subsubsection{Webinar: client side}

client side there is a distinction between teacher and student. Specifically, I created two Web Component:
\begin{enumerate}

\item The Web component in admin side can be invoked through the following snippet.
The use of such component performs the following operations:
\begin{itemize}
\item requires an id to the server listens
\item persists id webinar MongoDb
\item sets up the call
\item waits
\end{itemize}

\begin{lstlisting}[language=html]
 <deck-p2p-admin data="{{data.webinar}}" on-peer="on_peer"></deck-p2p-admin>
\end{lstlisting}

\item The web component in client side instead allows a user enrolled in a course and interested in the webinar to be able to access the content.
The use of this component performs the following operations:
\begin{itemize}
\item performs a GET to get the id of communication
\item requires an id to the server PeerJs
\item establishes a connection with the call of the teacher
\item shows the video content in real time
\end{itemize}

\end{enumerate}
\begin{lstlisting}[language=html]
  <deck-p2p-client class="video" data="{{data}}"></deck-p2p-client>
\end{lstlisting}


