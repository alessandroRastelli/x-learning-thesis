\newpage
\section{WebRTC: Overview}
\label{sec:WebRTC: Overview}


http://www.toptal.com/webrtc/taming-webrtc-with-peerjs

http://www.html5rocks.com/en/tutorials/webrtc/basics/

In X-Learning oltre ai video on-demand viene data la possibilità al teacher di programmare dei webinar.
Il webinar è un evento live, che permette a più persone di collegarsi in diretta per partecipare a una lezione interattiva, un corso di formazione, un workshop o una conferenza. Proprio come in un’aula reale ci si ritrova all’ora prestabilita e tutti hanno la possibilità di assistere e intervenire nel corso dell’evento per fare domande e condividere idee.

Per realizzare tale feature si è stato adottato WebRTC utile in tutti i contesti di video conferenza.

WebRTC born with the intention to offer Web Developers One Tool to manage the interchange of data stream between two devices direct connection ( peer-to -Peer ).
WebRTC (Web Real-Time Communication) is an API definition drafted by the World Wide Web Consortium (W3C) that supports browser-to-browser applications for voice calling, video chat, and P2P file sharing without the need of either internal or external plugins.[ How WebRTC Is Revolutionizing Telephony. Blogs.trilogy-lte.com (2014-02-21). Retrieved on 2014-04-11.]

Since it was first introduced by Google in May 2011, WebRTC has been used in many modern web applications. Being a core feature of many modern web browsers, web applications can seamlessly take advantage of this technology to deliver improved user experience in many ways. Video streaming or conferencing applications that don’t require bloated browser plugins, and can take advantage of peer-to-peer (P2P) networks (while not transmitting every bit of data through some server) is only a part of all the amazing things that can be achieved with WebRTC[http://www.toptal.com/webrtc/taming-webrtc-with-peerjs]
WebRTC is used in various apps like WhatsApp, Facebook Messenger, appear.in and platforms such as TokBox[http://www.html5rocks.com/en/tutorials/webrtc/basics/]

\subsection{WebRTC: PeerJS}
\label{sec:WebRTC: PeerJS}

To work around the implementation differences of WebRTC, in X-Learning i use an JavaScript library: PeerJS.
PeerJS takes the implementation of WebRTC in your browser and wraps a simple, consistent, and elegant API around it. It plugs various holes in WebRTC implementation of earlier browsers. 
With PeerJS, identifying peers is even simpler. Every peer is identified using nothing but an ID. A string that the peer can choose itself, or have a server generate one. Although WebRTC promises peer-to-peer communication, you still need a server anyway to act as a connection broker and handle signaling. PeerJS provides an open source implementation of this connection broker server PeerJS Server (written in Node.js), in case you do not want to use their cloud-hosted version (which is free right now, and comes with some limitations).
In my project i Hosting my own PeerJS Server. The official repository on GitHub even has a one-click button to deploy an instance of PeerJS Server to Heroku.
In my case, i just want to create an instance of ExpressPeerServer in my Node.js application, and serve it at “/peerjs”

\begin{lstlisting}[language=javascript]
// peerjs server
  var options = {
      debug: true
  }
  app.use('/peerjs', ExpressPeerServer(server, options));

  server.listen(9000);
\end{lstlisting}

\begin{lstlisting}[language=html]
 <deck-p2p-admin data="{{data.webinar}}" on-peer="on_peer"></deck-p2p-admin>
\end{lstlisting}

\begin{lstlisting}[language=html]
  <deck-p2p-client class="video" data="{{data}}"></deck-p2p-client>
\end{lstlisting}

With PeerJS Server up and running, I move on to the client side. As discussed earlier, PeerJS identifies peers with unique IDs. These IDs can be generated by PeerServer for every peer automatically, or we can pick one for every peer while instantiating Peer objects.

\begin{lstlisting}[language=javascript]
var peer = new Peer(id, options)
\end{lstlisting}

Here, id can be omitted altogether if we want the server to generate one for us. In my case, that is what i will want to do.PeerServer will ensure that the IDs it gives out are unique.The second argument, options, is usually an object containing key (the API key, if you are using cloud-hosted PeerServer, or host, port, path, etc in case you are hosting the PeerServer yourself).

\begin{lstlisting}[language=javascript]
var peer = this.peer = new Peer( { host: 'localhost', port: 9000, path: '/peerjs'});
\end{lstlisting}

In order to establish a connection between two PeerJS peers, one of the peers must know the ID of the other peer.

In my project i save the PeerJs use id into MongoDB ….


 With the destination peer ID known, a simple call to peer.connect(destId) is all that we will need
