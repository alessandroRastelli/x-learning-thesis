\newpage
\section{Real time video}
\label{sec:RealTimeVideo}

For the creation of server side webinar it was used PeerJs that allows the establishment and management of video conferences in a more simple and
cleaner than WebRTC. client side instead was create two distinct a web component for the teacher and one for the student wishing to
connect to the webinar.

\subsubsection{Webinar: server side}
To work around the implementation differences of WebRTC, in X-Learning i use an JavaScript library: PeerJS.
PeerJS takes the implementation of WebRTC in your browser and wraps a simple, consistent, and elegant API around it. It plugs various holes in WebRTC implementation of earlier browsers. 
With PeerJS, identifying peers is even simpler. Every peer is identified using nothing but an ID. A string that the peer can choose itself, or have a server generate one. Although WebRTC promises peer-to-peer communication, you still need a server anyway to act as a connection broker and handle signaling. PeerJS provides an open source implementation of this connection broker server PeerJS Server (written in Node.js), in case you do not want to use their cloud-hosted version (which is free right now, and comes with some limitations).
In my project i Hosting my own PeerJS Server. The official repository on GitHub even has a one-click button to deploy an instance of PeerJS Server to Heroku.
In my case, i just want to create an instance of ExpressPeerServer in my Node.js application, and serve it at “/peerjs”

\begin{lstlisting}[language=javascript]
// peerjs server
  var options = {
      debug: true
  }
  app.use('/peerjs', ExpressPeerServer(server, options));

  server.listen(9000);
\end{lstlisting}


With PeerJS Server up and running, I move on to the client side. As discussed earlier, PeerJS identifies peers with unique IDs. These IDs can be generated by PeerServer for every peer automatically, or we can pick one for every peer while instantiating Peer objects.

\begin{lstlisting}[language=javascript]
var peer = new Peer(id, options)
\end{lstlisting}

Here, id can be omitted altogether if we want the server to generate one for us. In my case, that is what i will want to do.PeerServer will ensure that the IDs it gives out are unique.The second argument, options, is usually an object containing key (the API key, if you are using cloud-hosted PeerServer, or host, port, path, etc in case you are hosting the PeerServer yourself).

\begin{lstlisting}[language=javascript]
var peer = this.peer = new Peer( { host: 'localhost', port: 9000, path: '/peerjs'});
\end{lstlisting}

In order to establish a connection between two PeerJS peers, one of the peers must know the ID of the other peer.

With the destination peer ID known, a simple call to peer.connect(destId) is all that we will need

\subsubsection{Webinar: client side}

client side there is a distinction between teacher and student. Specifically, I created two Web Component:
\begin{enumerate}

\item The Web component in admin side can be invoked through the following snippet.
The use of such component performs the following operations:
\begin{itemize}
\item requires an id to the server listens
\item persists id webinar MongoDb
\item sets up the call
\item waits
\end{itemize}

\begin{lstlisting}[language=html]
 <deck-p2p-admin data="{{data.webinar}}" on-peer="on_peer"></deck-p2p-admin>
\end{lstlisting}

\item The web component in client side instead allows a user enrolled in a course and interested in the webinar to be able to access the content.
The use of this component performs the following operations:
\begin{itemize}
\item performs a GET to get the id of communication
\item requires an id to the server PeerJs
\item establishes a connection with the call of the teacher
\item shows the video content in real time
\end{itemize}

\end{enumerate}
\begin{lstlisting}[language=html]
  <deck-p2p-client class="video" data="{{data}}"></deck-p2p-client>
\end{lstlisting}


